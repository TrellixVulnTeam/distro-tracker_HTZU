# Copyright 2013-2018 The Distro Tracker Developers
# See the COPYRIGHT file at the top-level directory of this distribution and
# at https://deb.li/DTAuthors
#
# This file is part of Distro Tracker. It is subject to the license terms
# in the LICENSE file found in the top-level directory of this
# distribution and at https://deb.li/DTLicense. No part of Distro Tracker,
# including this file, may be copied, modified, propagated, or distributed
# except according to the terms contained in the LICENSE file.
"""
Tests for the :mod:`distro_tracker.auto_news` app.
"""
from unittest import mock

from django.core.files.base import ContentFile

from distro_tracker.auto_news.tracker_tasks import (
    GenerateNewsFromRepositoryUpdates
)
from distro_tracker.core.models import (
    ExtractedSourceFile,
    News,
    Repository,
    SourcePackageRepositoryEntry
)
from distro_tracker.test import TestCase


class GenerateNewsFromRepositoryUpdatesTest(TestCase):
    """
    Tests the news generated by various repository updates.
    """
    def setUp(self):
        self.generate_news_task = GenerateNewsFromRepositoryUpdates()

    def run_task(self):
        self.generate_news_task.execute()

    def run_and_clear_news(self):
        self.run_task()
        News.objects.all().delete()

    def get_accepted_title(self, entry):
        title = '{pkg} {ver} has been added to {repo}'.format(
            pkg=entry.source_package.name, ver=entry.source_package.version,
            repo=entry.repository.name)
        return title

    def get_migrated_title(self, entry):
        title = '{pkg} {ver} migrated to {repo}'.format(
            pkg=entry.source_package.name, ver=entry.source_package.version,
            repo=entry.repository.name)
        return title

    def save_entry_details(self, entry):
        return {
            'pkg': entry.source_package.name,
            'repo': entry.repository.name,
        }

    def get_removed_title(self, details):
        title = '{pkg} has been removed from {repo}'.format(**details)
        return title

    def test_new_source_package(self):
        """
        Tests the case when a completely new source package is created (it was
        not seen in any repository previously).
        """
        srcpkg = self.create_source_package(repository='repo')

        self.run_task()

        # A news item was created
        self.assertEqual(1, News.objects.count())
        news = News.objects.all()[0]
        self.assertEqual(news.package.name, srcpkg.name)
        self.assertEqual(
            news.title,
            self.get_accepted_title(srcpkg.repository_entries.first())
        )

    def test_new_source_package_in_hidden_repository(self):
        """
        Tests the case when a completely new source package is created and
        appears in a hidden repository.
        """
        self.create_source_package(repository='repo')
        Repository.objects.get(shorthand='repo').flags.create(name='hidden',
                                                              value=True)

        self.run_task()

        # No news item is created
        self.assertEqual(0, News.objects.count())

    def test_new_source_package_version(self):
        """
        Tests the case when a new version of an already existing source package
        is created.
        """
        # Create the package, process it and drop the news
        srcpkg = self.create_source_package(repository='old')
        self.run_and_clear_news()
        # Add the package to another repository
        entry = self.add_to_repository(srcpkg, 'repo')

        self.run_task()

        # A news item was created
        self.assertEqual(1, News.objects.count())
        news = News.objects.all()[0]
        self.assertEqual(news.package.name, srcpkg.name)
        self.assertEqual(
            news.title,
            self.get_migrated_title(entry)
        )

    def test_new_source_package_version_in_hidden_repository(self):
        """
        Tests the case when a new version of an already existing source package
        is created in a hidden repository.
        """
        # Create the package, process it and drop the news
        srcpkg = self.create_source_package(repository='repo1')
        self.run_and_clear_news()
        # Add the package to another hidden epository
        entry = self.add_to_repository(srcpkg, 'repo2')
        entry.repository.flags.create(name='hidden', value=True)

        self.run_task()

        # No news item is created
        self.assertEqual(0, News.objects.count())

    def test_new_source_package_version_replaces_old_one(self):
        """
        Tests the case when a new version of an already existing source
        package is created and added to the repository which contains
        the old package version.
        """
        # Create the old version and make sure it is already in the
        # repository
        srcpkg1 = self.create_source_package(version='1', repository='repo')
        self.run_and_clear_news()
        # Now create the new version and make it replace the old version
        # in the repository
        self.create_source_package(version='2', repository='repo')
        self.remove_from_repository(srcpkg1, 'repo')

        self.run_task()

        # Only one news item is created
        self.assertEqual(1, News.objects.count())

    def assert_titles_match(self, get_title, entries=None):
        titles = set(News.objects.values_list('title', flat=True))
        expected_titles = set()
        if entries is None:
            entries = SourcePackageRepositoryEntry.objects.all()
        for entry in entries:
            expected_titles.add(get_title(entry))
        self.assertSetEqual(titles, expected_titles)

    def test_multiple_new_versions_same_repo(self):
        """
        Tests the case when there are multiple new versions in a repository.
        """
        # Create the package versions
        for version in ['1.0', '2.0']:
            self.create_source_package(version=version, repository='repo')

        self.run_task()

        # Two news items exist
        self.assertEqual(2, News.objects.count())
        self.assert_titles_match(self.get_accepted_title)

    def test_multiple_new_versions_different_repos(self):
        """
        Tests the case when there are multiple new versions of a source package
        each in a different repository.
        """
        versions = ['1.0.0', '1.1.0']
        repositories = ['repo1', 'repo2']
        # Create these versions
        for version, repository in zip(versions, repositories):
            self.create_source_package(version=version, repository=repository)

        self.run_task()

        self.assertEqual(2, News.objects.count())
        self.assert_titles_match(self.get_accepted_title)

    def test_package_version_add_different_repos(self):
        """
        Tests the case where a single existing package version is added to two
        repositories.
        """
        repositories = ['repo1', 'repo2']
        srcpkg = self.create_source_package(repository='old')
        self.run_and_clear_news()
        for repository in repositories:
            self.add_to_repository(srcpkg, repository)

        self.run_task()

        self.assertEqual(2, News.objects.count())
        entries = SourcePackageRepositoryEntry.objects.filter(
            repository__shorthand__in=repositories)
        self.assert_titles_match(self.get_migrated_title, entries)

    def test_package_version_add_different_repos_one_hidden(self):
        """
        Tests the case where a single existing package version is added to two
        repositories (one of them is hidden) and tests that a news is generated
        if the flag 'hidden' is false.
        """
        repositories = ['repo1', 'repo2']
        srcpkg = self.create_source_package(repository='old')
        self.run_and_clear_news()

        for repository in repositories:
            self.add_to_repository(srcpkg, repository)
        Repository.objects.get(shorthand='repo1').flags.create(name='hidden',
                                                               value=True)
        Repository.objects.get(shorthand='repo2').flags.create(name='hidden',
                                                               value=False)

        self.run_task()

        self.assertEqual(1, News.objects.count())

    def test_package_version_updates_different_repos(self):
        """
        Tests the case where a single existing package version is added to two
        repositories replacing the versions previously found in those
        repositories.
        """
        old_version = '1.0.0'
        version = '1.1.0'
        repositories = ['repo1', 'repo2']
        srcpkg_new = self.create_source_package(version=version,
                                                repository='old')
        srcpkg_old = self.create_source_package(version=old_version,
                                                repositories=repositories)
        self.run_and_clear_news()

        for repository in repositories:
            # Replace the old version with the new one
            self.remove_from_repository(srcpkg_old, repository)
            self.add_to_repository(srcpkg_new, repository)

        self.run_task()

        # Only two news messages.
        self.assertEqual(2, News.objects.count())
        entries = SourcePackageRepositoryEntry.objects.filter(
            repository__shorthand__in=repositories)
        self.assert_titles_match(self.get_migrated_title, entries)

    def test_multiple_package_updates_different_repos(self):
        """
        Tests the case where different repositories get different new package
        versions when they already previously had another version of the
        package.
        """
        old_version = '1.0.0'
        versions = ['1.1.0', '1.2.0']
        repositories = ['repo1', 'repo2']
        srcpkg_old = self.create_source_package(version=old_version,
                                                repositories=repositories)
        self.run_and_clear_news()

        # Add the new package version to each repository
        for version, repository in zip(versions, repositories):
            self.remove_from_repository(srcpkg_old, repository)
            self.create_source_package(version=version, repository=repository)

        self.run_task()

        self.assertEqual(2, News.objects.count())
        self.assert_titles_match(self.get_accepted_title)

    def test_source_package_removed(self):
        """
        Tests the case where a single source package version is removed
        from a repository.
        """
        srcpkg = self.create_source_package(repository='repo')
        self.run_and_clear_news()

        details = self.save_entry_details(srcpkg.repository_entries.first())
        self.remove_from_repository(srcpkg, 'repo')

        self.run_task()

        # A news item is created.
        self.assertEqual(1, News.objects.count())
        self.assertEqual(
            News.objects.all()[0].title,
            self.get_removed_title(details)
        )

    def test_source_package_removed_from_hidden_repository(self):
        """
        Tests the case where a single source package version is removed
        from a hidden repository.
        """
        srcpkg = self.create_source_package(repository='repo')
        Repository.objects.get(shorthand='repo').flags.create(name='hidden',
                                                              value=True)
        self.run_and_clear_news()

        self.remove_from_repository(srcpkg, 'repo')

        self.run_task()

        # No news item is created.
        self.assertEqual(0, News.objects.count())

    def test_migrate_from_a_hidden_repository(self):
        """
        Tests the case where a package version existing in a hidden repository
        is added to one repository.
        """
        srcpkg = self.create_source_package(repository='repo1')
        Repository.objects.get(shorthand='repo1').flags.create(name='hidden',
                                                               value=True)
        self.run_and_clear_news()

        # Add the version to another non-hidden repository
        entry = self.add_to_repository(srcpkg, 'repo2')

        self.run_task()

        # One news item - migrated to a non-hidden repository
        self.assertEqual(1, News.objects.count())
        news = News.objects.first()
        self.assertEqual(news.title, self.get_migrated_title(entry))

    def test_multiple_versions_removed_same_repo(self):
        """
        Tests the case where multiple versions of the same package are removed
        from the same repository and there are no more remaining versions of
        the package in that repository.
        """
        versions = ['1.0.0', '1.1.0']
        src_packages = []
        for version in versions:
            src_packages.append(
                self.create_source_package(version=version, repository='repo'))
        self.run_and_clear_news()

        details = self.save_entry_details(
            SourcePackageRepositoryEntry.objects.first())
        for srcpkg in src_packages:
            self.remove_from_repository(srcpkg, 'repo')

        self.run_task()

        # Only one news item should be created
        self.assertEqual(1, News.objects.count())
        news = News.objects.all()[0]
        self.assertEqual(news.title, self.get_removed_title(details))

    def test_only_one_version_removed(self):
        """
        Tests the case where a version is removed from the repository, but the
        repository still contains other versions of the same package.
        """
        versions = ['1.0.0', '1.1.0']
        for version in versions:
            srcpkg = self.create_source_package(version=version,
                                                repository='repo')
        self.run_and_clear_news()

        # Remove only one of the versions
        self.remove_from_repository(srcpkg, 'repo')

        self.run_task()

        # No news are generated
        self.assertEqual(0, News.objects.count())

    def test_migrate_and_remove(self):
        """
        Tests the case where a single package version is simultaneously
        added to one repository and removed from another.
        """
        srcpkg = self.create_source_package(repository='repo1')
        self.run_and_clear_news()
        details_removed = self.save_entry_details(
            srcpkg.repository_entries.first())

        # Add the version to one repository
        entry_added = self.add_to_repository(srcpkg, 'repo2')
        # Remove it from the one that already had it
        self.remove_from_repository(srcpkg, 'repo1')

        self.run_task()

        # Two news items - removed from one repositories, migrated to another
        self.assertEqual(2, News.objects.count())
        titles = set(News.objects.values_list('title', flat=True))
        expected_titles = set()
        expected_titles.add(self.get_migrated_title(entry_added))
        expected_titles.add(self.get_removed_title(details_removed))
        self.assertSetEqual(titles, expected_titles)

    def test_multiple_packages_added_same_repo(self):
        """
        Tests the case where multiple new packages are added to the same
        repository.
        """
        names = ['package1', 'package2']
        src_packages = []
        for name in names:
            src_packages.append(
                self.create_source_package(name=name, repository='repo1'))

        self.run_task()

        self.assertEqual(2, News.objects.count())
        for srcpkg in src_packages:
            news = srcpkg.source_package_name.news_set.first()
            entry = srcpkg.repository_entries.first()
            self.assertEqual(news.title, self.get_accepted_title(entry))

    def test_multiple_packages_removed_different_repos(self):
        """
        Tests the case where multiple packages are removed from different
        repositories.
        """
        names = ['package1', 'package2']
        repositories = ['repo1', 'repo2']
        src_packages = []
        for name, repository in zip(names, repositories):
            src_packages.append(
                self.create_source_package(name=name, repository=repository))
        self.run_and_clear_news()

        details_all = []
        for srcpkg, repository in zip(src_packages, repositories):
            # Remove the source package from the repository
            entry = srcpkg.repository_entries.first()
            details_all.append(self.save_entry_details(entry))
            self.remove_from_repository(srcpkg, repository)

        self.run_task()

        self.assertEqual(2, News.objects.count())
        for srcpkg, details in zip(src_packages, details_all):
            news = srcpkg.source_package_name.news_set.first()
            self.assertEqual(news.title, self.get_removed_title(details))

    @mock.patch('distro_tracker.auto_news.tracker_tasks.get_resource_content')
    def test_dsc_file_in_news_content(self, mock_get_resource_content):
        """
        Tests that the dsc file is found in the content of a news item created
        when a new package version appears.
        """
        self.create_source_package(repository='repo')
        expected_content = 'This is fake content'
        mock_get_resource_content.return_value = \
            expected_content.encode('utf-8')

        self.run_task()

        self.assertEqual(1, News.objects.count())
        news = News.objects.all()[0]
        self.assertEqual(news.content, expected_content)

    def test_changelog_entry_in_news_content(self):
        """
        Tests that the news item created for new source package versions
        contains the changelog entry for the version.
        """
        src_pkg = self.create_source_package(name='package', version='1.0.0',
                                             repository='repo')
        changelog_entry = (
            "package (1.0.0) suite; urgency=high\n\n"
            "  * New stable release:\n"
            "    - Feature 1\n"
            "    - Feature 2\n\n"
            " -- Maintainer <email@domain.com>  Mon, 1 July 2013 09:00:00 +0000"
        )
        ExtractedSourceFile.objects.create(
            source_package=src_pkg,
            extracted_file=ContentFile(changelog_entry, name='changelog'),
            name='changelog')

        self.run_task()

        self.assertEqual(News.objects.count(), 1)
        news = News.objects.all()[0]
        self.assertIn(changelog_entry, news.content)
